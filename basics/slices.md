# スライス

スライスは任意の型`T`に対する型`T[]`のオブジェクトです。
スライスは`T`値の配列の部分集合のビューを提供するか、
単に配列全体を指します。
**スライスと動的配列は同じものです。**

スライスは２つのメンバから構成されています。 - 
最初の要素へのポインタとスライスの長さです:

    T* ptr;
    size_t length; // 32bit環境なら符号なし32ビット、64bit環境なら符号なし64ビット

### 新しい割り当てによりスライスを得る

新しい動的配列が作成されるとき、新しく割り当てられたメモリからのスライスが返されます:

    auto arr = new int[5];
    assert(arr.length == 5); // メモリはarr.ptrから参照される

この場合実際に割り当てられたメモリは完璧にガベージコレクタによって管理され、
返されるスライスは根底にある要素の「ビュー」として振る舞います。

### 既存のメモリからスライスを得る

スライシング演算子を使いすでに存在するメモリと同じ所を指すスライスを得ることもできます。
スライシング演算子は別のスライス、静的配列、`opSlice`が実装されている構造体とクラスや
その他いくつかのエンティティに適用できます。

式の例`origin[start .. end]`の中のスライシング演算子は`origin`の
`start`から`end`の**前**までのすべての要素のスライスを得るのに使われます:

    auto newArr = arr[1 .. 4]; // インデックス4は含まれません
    assert(newArr.length == 3);
    newArr[0] = 10; // arr[1]の別名であるnewArr[0]を変更

そのようなスライスは既存のメモリの新しいビューを生成します。それは新しいコピーを作り**ません。**
メモリ、またはそのスライスされた部分への参照を持つスライスがない場合、それはガベージコレクタによって開放されます。

スライスを使うと、（たとえばパーサのような）1つのメモリブロックのみを操作し、
本当に必要な場所のみをスライスするようなものにおいて非常に効率的なコードを書くことができます。
この方法なら、新しいメモリブロックを割り当てる必要はありません。

前のセクションで見たように、`[$]`式は`arr.length`の短縮形です。
そのため`arr[$]`はスライスの最後のひとつ先の要素をインデックスし、
したがって`RangeError`を生成します（境界チェックが無効化されていなければ）。

### 掘り下げる

- [Introduction to Slices in D](http://dlang.org/d-array-article.html)
- [Slices in _Programming in D_](http://ddili.org/ders/d.en/slices.html)

## {SourceCode}

```d
import std.stdio;

/**
スライス内のすべての値の最小値を再帰的に計算します。
すべての再帰呼出しに対してサブスライスが呼び出され、
したがって新しいコピーを作らず、割り当てを行いません。
*/
int minimum(int[] slice)
{
    assert(slice.length > 0);
    if (slice.length == 1)
        return slice[0];
    auto otherMin = minimum(slice[1 .. $]);
    return slice[0] < otherMin ?
        slice[0] : otherMin;
}

void main()
{
    int[] test = [ 3, 9, 11, 7, 2, 76, 90, 6 ];
    auto min = minimum(test);
    writefln("The minimum of %s is %d",
        test, min);
    assert(min == 2);
}
```